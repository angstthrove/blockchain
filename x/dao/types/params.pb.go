// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: params.proto

package types

import (
	fmt "fmt"
	_ "github.com/cosmos/cosmos-proto"
	github_com_cosmos_cosmos_sdk_types "github.com/cosmos/cosmos-sdk/types"
	_ "github.com/cosmos/gogoproto/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// dao
type Params struct {
	Rate github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,1,opt,name=rate,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"rate"`
	
	MinDeviceRewardRatio github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,2,opt,name=min_device_reward_ratio,json=minDeviceRewardRatio,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"min_device_reward_ratio" yaml:"min_device_reward_ratio"`
	
	MaxDeviceRewardRatio github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,3,opt,name=max_device_reward_ratio,json=maxDeviceRewardRatio,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"max_device_reward_ratio" yaml:"max_device_reward_ratio"`
	
	MinSalaryRewardRatio github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,4,opt,name=min_salary_reward_ratio,json=minSalaryRewardRatio,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"min_salary_reward_ratio" yaml:"min_salary_reward_ratio"`
	
	MaxSalaryRewardRatio github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,5,opt,name=max_salary_reward_ratio,json=maxSalaryRewardRatio,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"max_salary_reward_ratio" yaml:"max_salary_reward_ratio"`
	// （100）
	BurnGetPowerRatio github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,6,opt,name=burn_get_power_ratio,json=burnGetPowerRatio,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"burn_get_power_ratio" yaml:"burn_get_power_ratio"`
	
	ClusterLevels []ClusterLevel `protobuf:"bytes,7,rep,name=ClusterLevels,proto3" json:"ClusterLevels"`
	
	MaxClusterMembers int64 `protobuf:"varint,8,opt,name=max_cluster_members,json=maxClusterMembers,proto3" json:"max_cluster_members,omitempty" yaml:"max_cluster_members"`
	
	MinCreateClusterPledgeAmount github_com_cosmos_cosmos_sdk_types.Int `protobuf:"bytes,9,opt,name=min_create_cluster_pledge_amount,json=minCreateClusterPledgeAmount,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Int" json:"min_create_cluster_pledge_amount"`
	//Dao 
	DaoRewardPercent github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,10,opt,name=dao_reward_percent,json=daoRewardPercent,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"dao_reward_percent" yaml:"dao_reward_percent"`
	//Dpos 
	DposRewardPercent github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,11,opt,name=dpos_reward_percent,json=dposRewardPercent,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"dpos_reward_percent" yaml:"dpos_reward_percent"`
	
	BurnCurrentGateRatio github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,12,opt,name=burn_current_gate_ratio,json=burnCurrentGateRatio,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"burn_current_gate_ratio" yaml:"burn_current_gate_ratio"`
	
	BurnRegisterGateRatio github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,13,opt,name=burn_register_gate_ratio,json=burnRegisterGateRatio,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"burn_register_gate_ratio" yaml:"burn_register_gate_ratio"`
	
	DayMintAmount github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,14,opt,name=day_mint_amount,json=dayMintAmount,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"day_mint_amount" yaml:"day_mint_amount"`
	
	BurnLevels []BurnLevel `protobuf:"bytes,15,rep,name=burnLevels,proto3" json:"burnLevels"`
	//gas
	PowerGasRatio github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,16,opt,name=power_gas_ratio,json=powerGasRatio,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"power_gas_ratio" yaml:"power_gas_ratio"`
}

func (m *Params) Reset()         { *m = Params{} }
func (m *Params) String() string { return proto.CompactTextString(m) }
func (*Params) ProtoMessage()    {}
func (*Params) Descriptor() ([]byte, []int) {
	return fileDescriptor_8679b07c520418a1, []int{0}
}
func (m *Params) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Params) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Params.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Params) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Params.Merge(m, src)
}
func (m *Params) XXX_Size() int {
	return m.Size()
}
func (m *Params) XXX_DiscardUnknown() {
	xxx_messageInfo_Params.DiscardUnknown(m)
}

var xxx_messageInfo_Params proto.InternalMessageInfo

func (m *Params) GetClusterLevels() []ClusterLevel {
	if m != nil {
		return m.ClusterLevels
	}
	return nil
}

func (m *Params) GetMaxClusterMembers() int64 {
	if m != nil {
		return m.MaxClusterMembers
	}
	return 0
}

func (m *Params) GetBurnLevels() []BurnLevel {
	if m != nil {
		return m.BurnLevels
	}
	return nil
}

type BurnLevel struct {
	Level      int64                                  `protobuf:"varint,1,opt,name=level,proto3" json:"level,omitempty" yaml:"level"`
	BurnAmount github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,2,opt,name=burn_amount,json=burnAmount,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"burn_amount" yaml:"burn_amount"`
	AddPercent github_com_cosmos_cosmos_sdk_types.Int `protobuf:"bytes,3,opt,name=add_percent,json=addPercent,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Int" json:"add_percent" yaml:"add_percent"`
	RoomAmount github_com_cosmos_cosmos_sdk_types.Int `protobuf:"bytes,4,opt,name=room_amount,json=roomAmount,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Int" json:"room_amount" yaml:"room_amount"`
}

func (m *BurnLevel) Reset()         { *m = BurnLevel{} }
func (m *BurnLevel) String() string { return proto.CompactTextString(m) }
func (*BurnLevel) ProtoMessage()    {}
func (*BurnLevel) Descriptor() ([]byte, []int) {
	return fileDescriptor_8679b07c520418a1, []int{1}
}
func (m *BurnLevel) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BurnLevel) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BurnLevel.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BurnLevel) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BurnLevel.Merge(m, src)
}
func (m *BurnLevel) XXX_Size() int {
	return m.Size()
}
func (m *BurnLevel) XXX_DiscardUnknown() {
	xxx_messageInfo_BurnLevel.DiscardUnknown(m)
}

var xxx_messageInfo_BurnLevel proto.InternalMessageInfo

func (m *BurnLevel) GetLevel() int64 {
	if m != nil {
		return m.Level
	}
	return 0
}

type ClusterLevel struct {
	Level        int64                                  `protobuf:"varint,1,opt,name=level,proto3" json:"level,omitempty" yaml:"level"`
	BurnAmount   github_com_cosmos_cosmos_sdk_types.Int `protobuf:"bytes,2,opt,name=burn_amount,json=burnAmount,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Int" json:"burn_amount"`
	MemberAmount int64                                  `protobuf:"varint,3,opt,name=member_amount,json=memberAmount,proto3" json:"member_amount,omitempty" yaml:"member_amount"`
}

func (m *ClusterLevel) Reset()         { *m = ClusterLevel{} }
func (m *ClusterLevel) String() string { return proto.CompactTextString(m) }
func (*ClusterLevel) ProtoMessage()    {}
func (*ClusterLevel) Descriptor() ([]byte, []int) {
	return fileDescriptor_8679b07c520418a1, []int{2}
}
func (m *ClusterLevel) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClusterLevel) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClusterLevel.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ClusterLevel) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClusterLevel.Merge(m, src)
}
func (m *ClusterLevel) XXX_Size() int {
	return m.Size()
}
func (m *ClusterLevel) XXX_DiscardUnknown() {
	xxx_messageInfo_ClusterLevel.DiscardUnknown(m)
}

var xxx_messageInfo_ClusterLevel proto.InternalMessageInfo

func (m *ClusterLevel) GetLevel() int64 {
	if m != nil {
		return m.Level
	}
	return 0
}

func (m *ClusterLevel) GetMemberAmount() int64 {
	if m != nil {
		return m.MemberAmount
	}
	return 0
}

func init() {
	proto.RegisterType((*Params)(nil), "freemasonry.dao.v1.Params")
	proto.RegisterType((*BurnLevel)(nil), "freemasonry.dao.v1.BurnLevel")
	proto.RegisterType((*ClusterLevel)(nil), "freemasonry.dao.v1.ClusterLevel")
}

func init() { proto.RegisterFile("params.proto", fileDescriptor_8679b07c520418a1) }

var fileDescriptor_8679b07c520418a1 = []byte{
	// 843 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x96, 0xcf, 0x6b, 0xdb, 0x48,
	0x14, 0xc7, 0xad, 0xd8, 0xc9, 0x6e, 0xc6, 0x76, 0x7e, 0x28, 0xde, 0x5d, 0x25, 0xbb, 0x2b, 0x9b,
	0x81, 0x0d, 0xb9, 0x44, 0x66, 0x77, 0x6f, 0xcb, 0x2e, 0xcb, 0xda, 0x81, 0x6c, 0x68, 0x52, 0xdc,
	0xe9, 0xad, 0x50, 0xc4, 0x58, 0x9a, 0x2a, 0x22, 0x96, 0x46, 0x8c, 0xc6, 0x89, 0x0d, 0xa5, 0xa7,
	0x42, 0xa1, 0xa7, 0xfe, 0x31, 0xfd, 0x23, 0x72, 0x0c, 0xa1, 0x87, 0xd2, 0x83, 0x29, 0xc9, 0xa5,
	0x67, 0xff, 0x05, 0x65, 0x66, 0xe4, 0x58, 0x4e, 0x64, 0xa8, 0xf0, 0x29, 0xd6, 0x7b, 0x33, 0xdf,
	0xf7, 0xd1, 0x77, 0xde, 0x1b, 0x05, 0x54, 0x22, 0xcc, 0x70, 0x10, 0x5b, 0x11, 0xa3, 0x9c, 0xea,
	0xfa, 0x0b, 0x46, 0x48, 0x80, 0x63, 0x1a, 0xb2, 0xa1, 0xe5, 0x62, 0x6a, 0x9d, 0xff, 0xbe, 0x53,
	0xf3, 0xa8, 0x47, 0x65, 0xba, 0x29, 0x7e, 0xa9, 0x95, 0x3b, 0xdb, 0x0e, 0x8d, 0x03, 0x1a, 0xdb,
	0x2a, 0xa1, 0x1e, 0x54, 0x0a, 0x5e, 0xaf, 0x81, 0x95, 0x8e, 0x54, 0xd5, 0x5b, 0xa0, 0xc4, 0x30,
	0x27, 0x86, 0xd6, 0xd0, 0xf6, 0x56, 0x5b, 0xd6, 0xe5, 0xa8, 0x5e, 0xf8, 0x34, 0xaa, 0xef, 0x7a,
	0x3e, 0x3f, 0xed, 0x77, 0x2d, 0x87, 0x06, 0xc9, 0xce, 0xe4, 0xcf, 0x7e, 0xec, 0x9e, 0x35, 0xf9,
	0x30, 0x22, 0xb1, 0x75, 0x40, 0x1c, 0x24, 0xf7, 0xea, 0x6f, 0x34, 0xf0, 0x53, 0xe0, 0x87, 0xb6,
	0x4b, 0xce, 0x7d, 0x87, 0xd8, 0x8c, 0x5c, 0x60, 0xe6, 0xda, 0x0c, 0x73, 0x9f, 0x1a, 0x4b, 0x52,
	0xb7, 0x93, 0x4f, 0x77, 0x3c, 0xaa, 0x9b, 0x43, 0x1c, 0xf4, 0xfe, 0x82, 0x73, 0x64, 0x21, 0xaa,
	0x05, 0x7e, 0x78, 0x20, 0x13, 0x48, 0xc6, 0x91, 0x08, 0x2b, 0x12, 0x3c, 0xc8, 0x24, 0x29, 0x2e,
	0x48, 0x92, 0x2d, 0x2b, 0x48, 0xf0, 0x60, 0x0e, 0x89, 0x1f, 0xda, 0x31, 0xee, 0x61, 0x36, 0x9c,
	0x25, 0x29, 0x2d, 0xee, 0x49, 0x86, 0xac, 0xf2, 0xe4, 0xa9, 0x4c, 0x64, 0x79, 0x92, 0x45, 0xb2,
	0xbc, 0xb8, 0x27, 0x73, 0x48, 0xf0, 0xe0, 0x21, 0xc9, 0x2b, 0x50, 0xeb, 0xf6, 0x59, 0x68, 0x7b,
	0x84, 0xdb, 0x11, 0xbd, 0x20, 0x2c, 0xa1, 0x58, 0x91, 0x14, 0x27, 0xb9, 0x29, 0x7e, 0x56, 0x14,
	0x59, 0x9a, 0x10, 0x6d, 0x8a, 0xf0, 0x21, 0xe1, 0x1d, 0x11, 0x54, 0xf5, 0x8f, 0x41, 0xb5, 0xdd,
	0xeb, 0xc7, 0x9c, 0xb0, 0x63, 0x72, 0x4e, 0x7a, 0xb1, 0xf1, 0x5d, 0xa3, 0xb8, 0x57, 0xfe, 0xa3,
	0x61, 0x3d, 0x9c, 0x29, 0x2b, 0xbd, 0xb0, 0x55, 0x12, 0x68, 0x68, 0x76, 0xb3, 0xfe, 0x18, 0x6c,
	0x89, 0xf7, 0x77, 0x54, 0xd0, 0x0e, 0x48, 0xd0, 0x25, 0x2c, 0x36, 0xbe, 0x6f, 0x68, 0x7b, 0xc5,
	0x96, 0x39, 0x1e, 0xd5, 0x77, 0xa6, 0x26, 0xdd, 0x5b, 0x04, 0xd1, 0x66, 0x80, 0x07, 0x89, 0xdc,
	0x89, 0x8a, 0xe9, 0xaf, 0x35, 0xd0, 0x10, 0x47, 0xeb, 0x30, 0x82, 0x39, 0xb9, 0xdb, 0x12, 0xf5,
	0x88, 0xeb, 0x11, 0x1b, 0x07, 0xb4, 0x1f, 0x72, 0x63, 0x55, 0x5a, 0xf5, 0x77, 0x0e, 0xab, 0x8e,
	0x42, 0x7e, 0xfd, 0x7e, 0x1f, 0x24, 0xf3, 0x7f, 0x14, 0x72, 0xf4, 0x4b, 0xe0, 0x87, 0x6d, 0x59,
	0x24, 0x21, 0xe8, 0xc8, 0x12, 0xff, 0xc9, 0x0a, 0xfa, 0x10, 0xe8, 0x2e, 0xa6, 0x93, 0xf3, 0x8c,
	0x08, 0x73, 0x48, 0xc8, 0x0d, 0x20, 0xeb, 0x3e, 0xca, 0x7d, 0x44, 0xdb, 0xca, 0x83, 0x87, 0x8a,
	0x10, 0x6d, 0xb8, 0x98, 0xaa, 0xee, 0xe8, 0xa8, 0x90, 0xfe, 0x12, 0x6c, 0xb9, 0x11, 0x8d, 0xef,
	0xd7, 0x2e, 0xcb, 0xda, 0xc7, 0xb9, 0x6b, 0x27, 0xfe, 0x67, 0x48, 0x42, 0xb4, 0x29, 0xa2, 0xb3,
	0xd5, 0xc5, 0x9c, 0xc8, 0x56, 0x72, 0xfa, 0x8c, 0x91, 0x90, 0xdb, 0x9e, 0x38, 0x06, 0xd5, 0xa1,
	0x95, 0xc5, 0xe6, 0x64, 0x8e, 0x2c, 0x44, 0x72, 0x1e, 0xda, 0x2a, 0x71, 0x88, 0x39, 0x51, 0x7d,
	0xfa, 0x56, 0x03, 0x86, 0xdc, 0xc2, 0x88, 0xe7, 0xcb, 0x26, 0x48, 0xa1, 0x54, 0x25, 0xca, 0x93,
	0xdc, 0x28, 0xf5, 0x14, 0x4a, 0x86, 0x2e, 0x44, 0x3f, 0x88, 0x14, 0x4a, 0x32, 0x53, 0x98, 0x08,
	0xac, 0xbb, 0x78, 0x68, 0x07, 0x7e, 0xc8, 0x27, 0x4d, 0xb8, 0x26, 0x11, 0xfe, 0xcf, 0x8d, 0xf0,
	0xe3, 0xa4, 0x19, 0x66, 0xe4, 0x20, 0xaa, 0xba, 0x78, 0x78, 0xe2, 0x87, 0x3c, 0xe9, 0xc0, 0x36,
	0x00, 0x02, 0x25, 0x99, 0xd1, 0x75, 0x39, 0xa3, 0xbf, 0x66, 0xcd, 0x68, 0x6b, 0xb2, 0x2a, 0x19,
	0xd0, 0xd4, 0x36, 0x81, 0xad, 0xae, 0x03, 0x0f, 0xc7, 0x89, 0x73, 0x1b, 0x8b, 0x61, 0xdf, 0x93,
	0x83, 0xa8, 0x2a, 0x23, 0x87, 0x38, 0x96, 0x46, 0xc1, 0x2f, 0x4b, 0x60, 0xf5, 0x8e, 0x48, 0xdf,
	0x05, 0xcb, 0x3d, 0xf1, 0x43, 0x7e, 0x58, 0x8b, 0xad, 0x8d, 0xf1, 0xa8, 0x5e, 0x51, 0x3a, 0x32,
	0x0c, 0x91, 0x4a, 0xeb, 0x04, 0x94, 0xe5, 0x91, 0x24, 0xd6, 0xaa, 0xcf, 0xe5, 0x41, 0x6e, 0x46,
	0x3d, 0x75, 0xba, 0x13, 0x5b, 0xa5, 0x1d, 0x89, 0xa7, 0x04, 0x94, 0xb1, 0x3b, 0x1d, 0xa9, 0x62,
	0xee, 0x32, 0x47, 0x21, 0x9f, 0x96, 0x49, 0x49, 0x41, 0x04, 0xb0, 0x7b, 0x37, 0x43, 0x04, 0x94,
	0x19, 0xa5, 0xc1, 0xe4, 0x6d, 0x4a, 0x8b, 0x95, 0x49, 0x49, 0x41, 0x04, 0xc4, 0x93, 0x7a, 0x1b,
	0xf8, 0x41, 0x03, 0x95, 0xf4, 0x65, 0xfc, 0xcd, 0x6e, 0x3f, 0xcf, 0x72, 0x7b, 0xb1, 0xdb, 0x34,
	0xed, 0xf2, 0x3f, 0xa0, 0xaa, 0x6e, 0xf8, 0x49, 0x81, 0xa2, 0xc4, 0x31, 0xc6, 0xa3, 0x7a, 0x2d,
	0xf9, 0x18, 0xa4, 0xd3, 0x10, 0x55, 0xd4, 0xb3, 0xda, 0xde, 0xfa, 0xf7, 0xf2, 0xc6, 0xd4, 0xae,
	0x6e, 0x4c, 0xed, 0xf3, 0x8d, 0xa9, 0xbd, 0xbb, 0x35, 0x0b, 0x57, 0xb7, 0x66, 0xe1, 0xe3, 0xad,
	0x59, 0x78, 0xf6, 0x5b, 0xba, 0xfb, 0x1d, 0xa7, 0xd9, 0xed, 0x51, 0xe7, 0xcc, 0x39, 0xc5, 0x7e,
	0xd8, 0x1c, 0x34, 0x5d, 0x4c, 0x15, 0x5d, 0x77, 0x45, 0xfe, 0x7b, 0xf7, 0xe7, 0xd7, 0x00, 0x00,
	0x00, 0xff, 0xff, 0x4c, 0xba, 0x64, 0x3f, 0x33, 0x0a, 0x00, 0x00,
}

func (m *Params) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Params) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Params) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.PowerGasRatio.Size()
		i -= size
		if _, err := m.PowerGasRatio.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintParams(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0x82
	if len(m.BurnLevels) > 0 {
		for iNdEx := len(m.BurnLevels) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.BurnLevels[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintParams(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x7a
		}
	}
	{
		size := m.DayMintAmount.Size()
		i -= size
		if _, err := m.DayMintAmount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintParams(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x72
	{
		size := m.BurnRegisterGateRatio.Size()
		i -= size
		if _, err := m.BurnRegisterGateRatio.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintParams(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x6a
	{
		size := m.BurnCurrentGateRatio.Size()
		i -= size
		if _, err := m.BurnCurrentGateRatio.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintParams(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x62
	{
		size := m.DposRewardPercent.Size()
		i -= size
		if _, err := m.DposRewardPercent.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintParams(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x5a
	{
		size := m.DaoRewardPercent.Size()
		i -= size
		if _, err := m.DaoRewardPercent.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintParams(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x52
	{
		size := m.MinCreateClusterPledgeAmount.Size()
		i -= size
		if _, err := m.MinCreateClusterPledgeAmount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintParams(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x4a
	if m.MaxClusterMembers != 0 {
		i = encodeVarintParams(dAtA, i, uint64(m.MaxClusterMembers))
		i--
		dAtA[i] = 0x40
	}
	if len(m.ClusterLevels) > 0 {
		for iNdEx := len(m.ClusterLevels) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ClusterLevels[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintParams(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	{
		size := m.BurnGetPowerRatio.Size()
		i -= size
		if _, err := m.BurnGetPowerRatio.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintParams(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x32
	{
		size := m.MaxSalaryRewardRatio.Size()
		i -= size
		if _, err := m.MaxSalaryRewardRatio.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintParams(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	{
		size := m.MinSalaryRewardRatio.Size()
		i -= size
		if _, err := m.MinSalaryRewardRatio.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintParams(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	{
		size := m.MaxDeviceRewardRatio.Size()
		i -= size
		if _, err := m.MaxDeviceRewardRatio.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintParams(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size := m.MinDeviceRewardRatio.Size()
		i -= size
		if _, err := m.MinDeviceRewardRatio.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintParams(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size := m.Rate.Size()
		i -= size
		if _, err := m.Rate.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintParams(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *BurnLevel) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BurnLevel) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BurnLevel) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.RoomAmount.Size()
		i -= size
		if _, err := m.RoomAmount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintParams(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	{
		size := m.AddPercent.Size()
		i -= size
		if _, err := m.AddPercent.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintParams(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size := m.BurnAmount.Size()
		i -= size
		if _, err := m.BurnAmount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintParams(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if m.Level != 0 {
		i = encodeVarintParams(dAtA, i, uint64(m.Level))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ClusterLevel) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClusterLevel) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClusterLevel) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MemberAmount != 0 {
		i = encodeVarintParams(dAtA, i, uint64(m.MemberAmount))
		i--
		dAtA[i] = 0x18
	}
	{
		size := m.BurnAmount.Size()
		i -= size
		if _, err := m.BurnAmount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintParams(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if m.Level != 0 {
		i = encodeVarintParams(dAtA, i, uint64(m.Level))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintParams(dAtA []byte, offset int, v uint64) int {
	offset -= sovParams(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Params) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Rate.Size()
	n += 1 + l + sovParams(uint64(l))
	l = m.MinDeviceRewardRatio.Size()
	n += 1 + l + sovParams(uint64(l))
	l = m.MaxDeviceRewardRatio.Size()
	n += 1 + l + sovParams(uint64(l))
	l = m.MinSalaryRewardRatio.Size()
	n += 1 + l + sovParams(uint64(l))
	l = m.MaxSalaryRewardRatio.Size()
	n += 1 + l + sovParams(uint64(l))
	l = m.BurnGetPowerRatio.Size()
	n += 1 + l + sovParams(uint64(l))
	if len(m.ClusterLevels) > 0 {
		for _, e := range m.ClusterLevels {
			l = e.Size()
			n += 1 + l + sovParams(uint64(l))
		}
	}
	if m.MaxClusterMembers != 0 {
		n += 1 + sovParams(uint64(m.MaxClusterMembers))
	}
	l = m.MinCreateClusterPledgeAmount.Size()
	n += 1 + l + sovParams(uint64(l))
	l = m.DaoRewardPercent.Size()
	n += 1 + l + sovParams(uint64(l))
	l = m.DposRewardPercent.Size()
	n += 1 + l + sovParams(uint64(l))
	l = m.BurnCurrentGateRatio.Size()
	n += 1 + l + sovParams(uint64(l))
	l = m.BurnRegisterGateRatio.Size()
	n += 1 + l + sovParams(uint64(l))
	l = m.DayMintAmount.Size()
	n += 1 + l + sovParams(uint64(l))
	if len(m.BurnLevels) > 0 {
		for _, e := range m.BurnLevels {
			l = e.Size()
			n += 1 + l + sovParams(uint64(l))
		}
	}
	l = m.PowerGasRatio.Size()
	n += 2 + l + sovParams(uint64(l))
	return n
}

func (m *BurnLevel) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Level != 0 {
		n += 1 + sovParams(uint64(m.Level))
	}
	l = m.BurnAmount.Size()
	n += 1 + l + sovParams(uint64(l))
	l = m.AddPercent.Size()
	n += 1 + l + sovParams(uint64(l))
	l = m.RoomAmount.Size()
	n += 1 + l + sovParams(uint64(l))
	return n
}

func (m *ClusterLevel) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Level != 0 {
		n += 1 + sovParams(uint64(m.Level))
	}
	l = m.BurnAmount.Size()
	n += 1 + l + sovParams(uint64(l))
	if m.MemberAmount != 0 {
		n += 1 + sovParams(uint64(m.MemberAmount))
	}
	return n
}

func sovParams(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozParams(x uint64) (n int) {
	return sovParams(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Params) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowParams
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Params: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Params: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Rate.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinDeviceRewardRatio", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MinDeviceRewardRatio.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxDeviceRewardRatio", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MaxDeviceRewardRatio.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinSalaryRewardRatio", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MinSalaryRewardRatio.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxSalaryRewardRatio", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MaxSalaryRewardRatio.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BurnGetPowerRatio", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.BurnGetPowerRatio.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterLevels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClusterLevels = append(m.ClusterLevels, ClusterLevel{})
			if err := m.ClusterLevels[len(m.ClusterLevels)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxClusterMembers", wireType)
			}
			m.MaxClusterMembers = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxClusterMembers |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinCreateClusterPledgeAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MinCreateClusterPledgeAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DaoRewardPercent", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.DaoRewardPercent.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DposRewardPercent", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.DposRewardPercent.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BurnCurrentGateRatio", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.BurnCurrentGateRatio.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BurnRegisterGateRatio", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.BurnRegisterGateRatio.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DayMintAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.DayMintAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BurnLevels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BurnLevels = append(m.BurnLevels, BurnLevel{})
			if err := m.BurnLevels[len(m.BurnLevels)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PowerGasRatio", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.PowerGasRatio.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipParams(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthParams
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BurnLevel) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowParams
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BurnLevel: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BurnLevel: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			m.Level = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Level |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BurnAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.BurnAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddPercent", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.AddPercent.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoomAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RoomAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipParams(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthParams
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClusterLevel) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowParams
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClusterLevel: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClusterLevel: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			m.Level = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Level |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BurnAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.BurnAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemberAmount", wireType)
			}
			m.MemberAmount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MemberAmount |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipParams(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthParams
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipParams(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowParams
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowParams
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowParams
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthParams
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupParams
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthParams
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthParams        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowParams          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupParams = fmt.Errorf("proto: unexpected end of group")
)
